# 🌟 5.2 리액트 훅으로 시작하는 상태 관리

## 📌 5.2.1 가장 기본적인 방법: useState와 useReducer

```js
function useCounter(initCount: number = 0) {
  const [counter, setCounter] = useState(initCount);

  function inc() {
    setCounter((prev) => prev + 1);
  }

  return { counter, inc };
}
```

- useState는 useReducer로 구현 가능, 반대도 가능
- 두 컴포넌트가 동일한 상태를 바라보게 하기 위해서는, 상태를 컴포넌트 밖으로 한 단계 끌어올리는 것 -> props로 전달해야하는 번거로움이 있음

## 📌 5.2.2 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

함수 외부에서 상태를 참조하고 이를 통해 렌더링까지 자연스럽게 일어나려면

1. 꼭 window나 global에 있어야 할 필요는 없지만 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 한다.
2. 이 외부에 있는 상태를 사용하는 컴포넌트는 상태의 변화를 알아챌 수 있어야 하고 상태가 변화될 때마다 리렌더링이 일어나서 컴포넌트를 최신 상태값 기준으로 렌더링해댜 한다. 이 상태 감지는 상태를 변경시키는 컴포넌트뿐만 아니라 이 상태를 참조하는 모든 컴포넌트에서 동일하게 작동해야 한다.
3. 상태가 원시값이 아닌 객체인 경우에 그 객테에 내가 감지하지 않는 값이 변한다 하더라도 리렌더링이 발생해서는 안된다.

```js
export const createStore = <State extends unknown>(
  initialState: Initializer<State>,
): Store<State> => {
  // useState와 마찬가지로 초깃값을 게으른 초기화를 위한 함수 또한
  // 그냥 값을 받을 수 있도록 한다.
  // state의 값은 스토어 내부에서 보관해야 하므로 변수로 선언한다.
  let state = typeof initialState !== 'function' ? initialState : initialState()

  // callbacks는 자료형과 관계없이 유일한 값을 저장할 수 있는 Set을 사용한다.
  const callbacks = new Set<() => void>()

  const get = () => state
  const set = (nextState: State | ((prev: State) => State)) => {
    // 인수가 함수라면 함수를 실행해 새로운 값을 받고, 아니라면 새로운 값을 그대로 사용한다.
    state = typeof nextState === 'funciton' ? (nextState as (prev: State) => State)(state) : nextState

    // 값의 설정이 발생하면 콜백 목록을 순회하면서 모든 콜백을 실행한다.
    callbacks.forEach((callback) => callback())

    return state
  }

  const subscribe = (callback: () => void) => {
    // 받은 함수를 콜백 목록에 추가한다.
    callbacks.add(callback)
    // 클린업 실행 시 이를 삭제go서 반복적으로 추가되는 것을 막는다.
   return () => {
    callbacks.delete(callback)
   }
  }

  return { get, set, subscribe }
}
```

```js
export const useStore = <State extends unknown>(store: Store<state>) => {
  // 컴포넌트 렌더링 유도
  const [state, setState] = useState<State>(() => store.get())

  // useEffect는 store의 현재 값을 가져와 setState를 수행하는 함수를 store의 subscribe로 등록해 두었다. createStore 내부에서 값이 변경될 때마다 subscribe에 등록된 함수를 실행하므로 useStore 내부에서는 store의 값이 변경될 때마다 state의 값이 변경되는 것을 보장
  useEffect(() => {
    const unscribe = store.subscribe(() => {
      setState(store.get())
    })
    // useEffect의 작동이 끝난 이후에는 callback에서 해당 함수를 제거해 callback이 계속 쌓이는 현상 방지
    return unsubscribe
  }, [store])

  return [state, store.set] as const
}
```

- useSubscription을 사용하면 위와 같은 방식으로 외부에 있는 데이터를 가져와서 사용하고 리렌더링까지 정상적으로 수행
  - React 18: useSyncExternalStore
    https://ko.react.dev/reference/react/useSyncExternalStore

## 📌 5.2.3 useState와 Context를 동시에 사용해보기

- store을 여러개 사용하고 싶을 때, Context와 함께 쓰면 된다.

```js
// Context를 생성하면 자동으로 스토어도 함께 생성
export const CounterStoreContext = createContext<Store<CounterStore>>(
  createStore<CounterStore>({ count: 0, text: 'hello' }),
)

export const CounterStoreProvider = ({
  initialState,
  children,
}: PropsWithChildren<{
  initialState: CounterState
}>) => {
  const storeRef = useRef<Store<CounterStore>>()

  // 스토어를 생성한 적이 없다면 최초에 한 번 생성한다.
  if (!storeRef.current) {
    storeRef.current = createStore(initialState)
  }

  return (
    <CounterStoreContext.Provider value={storeRef.current}>
      {children}
    </CounterStoreContext.Provider>
  )
}
```

```js
export const useCounterContextSElector = <State extends unknown>(
  selector: (state: CounterStore) => State,
) => {
  const store = useContext(CounterStoreContext)

  // useSelectorSelector를 사용해도 동일
  const subscription = useSubscription(
    useMemo(
      () => ({
        getCurrentValue: () => selector(store.get()),
        subscribe: store.subscribe,
      }),
      [store, selector],
    ),
  )

  return [subscription, store.set] as const
}
```

## 📌 5.2.4 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기

### 페이스북이 만든 상태 관리 라이브러리 Recoil

- 훅의 개념으로 상태 관리
- Atom을 처음 리액트 생태계에서 선보이기도 함
- 아직 정식 출시 안함(!) 지금도 v0.7.7

```js
// atom: 상태를 나타내는 Recoil의 최소 상태 단위
const counterState = atom({
  key: "counterState", // 다른 atom과 구별하는 식별자가 되는 필수 값
  default: 0,
});

function Counter() {
  const [, setCount] = useRecoilState(counterState);

  function handleButtonClick() {
    setCount((count) => count + 1);
  }

  return (
    <>
      <button onCLick={handleButtonClick}>+</button>
    </>
  );
}

// atom을 기반으로 또 다른 상태를 만들 수 있다.
const isBiggerThan10 = selector({
  key: "above10State",
  get: ({ get }) => {
    return get(counterSTate) >= 10;
  },
});

function Count() {
  const count = useRecoilValue(counterState);
  const biggerThan10 = useRecoilValue(isBiggerThan10);

  return (
    <>
      <h3>{count}</h3>
      <p>count is bigger than 10: {JSON.stringify(biggerThan10)}</p>
    </>
  );
}

export default function App() {
  return (
    <RecoilRoot>
      <Counter/>
      <Count/>
    </RecoilRoot>
  )
}
```
- 비동기 작업을 지원하는 API 제공

### Recoil에서 영감을 받은, 그러나 조금 더 유연한 Jotai
```js
// **
const counterState = atom(0);

function Counter() {
  // **
  const [, setCount] = useAtom(counterState);

  function handleButtonClick() {
    setCount((count) => count + 1);
  }

  return (
    <>
      <button onCLick={handleButtonClick}>+</button>
    </>
  );
}

// **
const isBiggerThan10 = atom((get) => get(counterState) > 10)

function Count() {
  // **
  const count = useAtomValue(counterState);
  const biggerThan10 = useAtomValue(isBiggerThan10);

  return (
    <>
      <h3>{count}</h3>
      <p>count is bigger than 10: {JSON.stringify(biggerThan10)}</p>
    </>
  );
}

export default function App() {
  return (
    <>
      <Counter/>
      <Count/>
    </>
  )
}
```
- atom API는 리액트의 useState와는 다르게 컴포넌트 외부에서도 선언할 수 있다.
- atom은 값뿐만 아니라 함수를 인수로 받을 수 있는데, 이러한 특징을 활용해 다른 atom의 값으로 부터 파생된 atom을 만들 수 있다.
- key 필요 X, selector 없음

### 작고 빠르며 확장에도 유연한 Zustand
- 간단하다
- 라이브러리 크리가 작다
- 타입스크립트 기반으로 작성
- 리덕스와 마찬가지로 미들웨어 제공
  - persist: 스토어 데이터 영구 보존
  - immer: 복잡한 객체를 관리하기 쉽게 도와줌
  